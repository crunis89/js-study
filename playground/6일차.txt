[객체복사]
객체복사에는 얕은복사 깊은복사가 있다.

var o ={
a : 1,
b: {
     c : 1
    }
};
[함수선언문]
끝날 때 ; 을 붙히고 여부는 생략가능/ 값이 아니기 때문에

[함수표현식]
끝날 때 ;를 붙힌다. 할당문이 끝났기 때문에

[함수리터럴]
리터럴은 함수이름이 있어도 되고 없어도 된다. (즉 생략가능)
*함수이름은 함수 몸체 내에서만 참조할 수 있는 식별자다.

매개변수 목록은 순서에 의미가 있다 (순차)
매게변수는 함수 몸체 내에서 변수와 동일하게 취급

함수몸체는 문들이 온다 

함수 선언문과 함수리터럴을 구별할 수 있어야 한다.
함수선언문의 함수 호이스팅은 실체를 호출 및 참조까지 해준다.
(함수호이스팅은 함수객체로 초기화되기 때문에 선언문 이전에 호출해도 호출가능.
/함수객체가 먼저 생서되고 식별자에 값까지 할당까지 완료)

호출할 때는 함수객체를 가르키고 있는 식별자를 호출해야 한다

[비교 꼭 다시 이해하기]
// 이름이 있는 함수 리터럴을 단독으로 사용하면 함수 선언문으로 해석한다.
// 함수 선언문은 함수 이름을 생략할 수 없다.
function foo() { console.log('foo'); }
foo(); // foo

// 함수 리터럴을 피연산자로 사용하면 함수 선언문이 아니라 함수 리터럴 표현식로 해석한다.
// 함수 리터럴은 함수 이름을 생략할 수 있다.
(function bar() { console.log('bar'); });
bar(); // ReferenceError: bar is not defined

참조후에 호출한다 foo참조 ( )호출  foo( ) 참조 후 호출


함수내부에는 (arguments) 라는 객체가 암묵적으로 주어진다.


[즉시실행함수 = IIFE]
단 한번만 호출할수있으며 선언과 동시에 실행한다.
-사용목적
1. 인위적인 스코프를 만들 때
2. 함수가 호출되면 태어나서 끝날때 죽음


[중첩함수]



*배열가지고 반복할 떄는 포문을 돌아야한다.
[1,2,3,4,5].map()
